# aydoo-2016-e1

TP N°1 Grupal para AyDOO - Equipo Número 1: 
- Pena, Gabriel.
- Di Pierro, Gonzalo Nahuel.

Descripción del Diseño:

Hemos implementado un sistema de arquitectura estilo pipeline:  se toma como entrada un archivo de especificacion, más el contenido de la carpeta plantilla y un set de parametros, sobre los que se irán ejecutando distintas operaciones en orden hasta producir una salida. 

La primera seccion del programa es un conjunto de clases que se encargan de gestionar y validar la entrada: las clases OrdenadorDeTareas, OrdenadorDeParametros, ValidadorDeParametros, LectorDeEntrada. Un objeto OrdenadorDeParametros es creado por la clase principal del programa, y a el le pasa la lista de parametros. Esta clase se encarga de ejecutar, en orden, una cierta cantidad de operaciones (que son delegadas individualmente a las demas clases): ordenar los parametros, realizar validaciones, leer el archivo de entrada. En este punto, ya todos los parametros especificados son considerados validos (excepto, eventualmente, el contenido del archivo, el cual se valida mas adelante).

Cuando el ordenador de tareas le pide a un objeto de tipo LectorDeEntrada que lea el archivo especificado, obtiene una lista de Strings donde cada posicion contiene una linea del archivo leido. Entonces, el ordenador de tareas llama a un objeto del tipo ConstructorDeEstructura y le pasa la lista de lineas leidas. A partir de esto, el ConstructorDeEstructura sabe construir una EstructuraDeSecciones, que es un objeto que modela completamente el contenido de un slide: tiene una serie de secciones, que pueden tener dentro listas, titulos, subtitulos, imagenes y texto plano. Cada uno de estos elementos es modelado como una clase, y asimismo los items de una lista. Para hacer esto, el constructor recorre la lista de strings y diferencia las secciones, luego llama a un ConstructorDeSeccion que sabe construir una seccion dados todos los strings que representen contenido que una seccion pueda tener dentro. Este ultimo constructor tiene dentro un RepositorioDeObjetos del cual puede obtener los elementos que va a devolver, y la logica esta en saber elegir el correcto para cada linea y en poder manejar correctamente las listas, que ocupan varias lineas. Se podra ver mas claro en los diagramas de secuencia.

Con el modelo de objetos del problema ya creado, se procede a realizar una transformacion para convertirlo en un modelo analogo pero que representa codigo HTML. Para eso, se utiliza un objeto de tipo Transformador, el cual toma un objeto del tipo Transformable y devuelve su transformado. Como estos objetos son recursivos, se le pide transformar la estructura de secciones, y esto implica que la estructura de secciones, internamente, transforma cada uno de sus elementos contenidos hasta llegar a los de mas bajo nivel, y el resultado de la transformacion completa es un objeto de tipo CodigoHTML que representa el codigo que sera escrito en la salida, con todas sus etiquetas ya puestas correctamente.

Con el codigo ya creado, el ultimo paso  es que el ordenador de tareas llame a un objeto de tipo GeneradorDeSalida y le pida que escriba el codigo en la salida correspondiente. Aqui se decide, segun los parametros recibidos, si la salida va al archivo index.html (default) o a system.out (no-output), de manera que este objeto es el unico que toca la salida del programa.

El objetivo principal del diseño fue lograr una gran modularizacion, que cada clase tuviera responsabilidad limitada y pocas lineas de codigo (dentro de lo posible). En general se trato de hacer logicas facilmente extensibles, y es para esto que armamos a pulmon un modelo de objetos que represente nuestro archivo de entrada y otro que represente nuestra salida: de esta manera, agregar pequeñas cosas no supone un conflicto. Hubo algunas clases con las que no pudimos lograr del todo esto y quedaron logicas no demasiado amigables (por ejemplo, la de reconocer donde termina una seccion dada una lista de strings) y quizas con mas tiempo se podrian refactorizar y mejorar. Lo mismo la clase OrdenadorDeTareas, la cual gestiona la realizacion de varias operaciones, resultando tener cierto acoplamiento. A futuro, si se vuelve a trabajar sobre este codigo, se podria refactorizar esa clase en un pequeño conjunto de clases (que bien podrian ser las existentes), pero que se pasen la entrada las unas a las otras y vayan agregando informacion.



